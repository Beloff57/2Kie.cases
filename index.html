<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2Kie da - case</title>
    <link rel="stylesheet" href="styles/style.css">
</head>
<body>


<div id="circularButton" class="fixed-bottom-right">
  <div class="arrow-container">
    <img src="images/Arrow 27.svg" alt="Стрелка" class="arrow">
  </div>
  <div class="text-container">
<svg width="100" height="100" viewBox="0 0 100 100">
  <path id="circlePath" d="M 50,10 a 40,40 0 1,1 0,80 40,40 0 1,1 0,-80" fill="none" stroke="transparent"/>
  <text font-size="10" font-family="Arial">
    <textPath href="#circlePath" textLength="251.2" startOffset="0%">
     &middot;обсудить проект&middot;обсудить проект
    </textPath>
  </text>
</svg>
  </div>
</div>

    <section class="hero-content">
    <img src="images/Rectangle 75.png" alt="">
    <div class="hero-overlay">
      <div class="logo-container">
        <a href="" target="_blank">
          <img src="images/Group white.svg" alt="Логотип 2kie">
        </a>
      </div>
      <div class="nav-wrapper">
    <div class="vertical-links">
      <a href="/case.html" class="nav-link">Кейсы</a>
      <a href="/uslugi.html" class="nav-link">Услуги</a>
      <a href="/index.html" class="nav-link">Студия</a>
    </div>
  </div>
      <div class="mute-btn" id="muteBtn">
        <img src="images/mute-Vector.svg" alt="Mute">
      </div>
    </div>
    <div class="play-btn" id="playBtn">
        <img src="images/play.svg" alt="Play" class="btn-play">
    </div>
    <div class="button-group-2">
      <a href="#" class="btn-wht">Branding</a>
      <a href="#" class="btn-wht">Logo</a>
    </div>
    </section>
    <section class="info-block">
<div class="case-wrapper">
  <main class="case-left">
    <section id="s1" class="case-section">
      <div class="cs-1">
        <h2>Арвис - создание цикличной экосистемы</h2>
        <p>Дизайн и разработка цифровых сервисов, сайтов и приложений с нуля. Поиск новых решений для развития существующих продуктов</p>
        <p>Дизайн и разработка цифровых сервисов, сайтов и приложений с нуля. Поиск новых решений для развития существующих продуктов Дизайн и разработка цифровых сервисов, сайтов и приложений с нуля. Поиск новых решений для развития существующих продуктов</p>
      </div>
      <div class="cs-2">
        <img src="images/ft1.png" alt="" class="fs-1">
        <img src="images/ft2.png" alt="" class="fs-2">
      </div>
    </section>
    <section id="s2" class="case-section"><h2>Design</h2><p></p></section>
    <section id="s3" class="case-section"><h2>UX/UI</h2><p></p></section>
    <section id="s4" class="case-section"><h2>Web</h2><p></p></section>
    <section id="s5" class="case-section final"><h2>Final</h2><p></p></section>
  </main>
  <aside class="case-right" aria-label="Навигация по секциям">
    <div class="nav-inner">
    <div class="track" id="track">
      <div class="track-line" id="trackLine"></div>           <!-- вертикальная линия (будет динамичной высоты) -->
      <div class="track-end-dot" id="trackEndDot"></div>      <!-- маленькая окружность внизу напротив Final -->
      <div class="track-indicator" id="trackIndicator">       <!-- сам индикатор, внутри — connector -->
      <div class="connector" id="indicatorConnector"></div>
      <div class="connector-dot" id="connectorDot"></div>
      </div>
    </div>
              <div class="video-block">
            <img src="images/Rectangle 422.png" alt="" class="b-video">
            <div class="podpis">О проекте</div>
            <div class="play-btn-2" id="playBtn">
              <img src="images/play.svg" alt="Play" class="btn-play2">
            </div>
          </div>
      <nav class="side-nav" id="sideNav">
        <button class="nav-item" data-target="s1"><span class="num">1.</span><span class="title">Analitic</span></button>
        <button class="nav-item" data-target="s2"><span class="num">2.</span><span class="title">Design</span></button>
        <button class="nav-item" data-target="s3"><span class="num">3.</span><span class="title">UX/UI</span></button>
        <button class="nav-item" data-target="s4"><span class="num">4.</span><span class="title">Web</span></button>
        <!-- пустое пространство, final располагается отдельно -->
        <div class="nav-spacer"></div>
        <button class="nav-item nav-final" data-target="s5"><span class="num">Final</span></button>
      </nav>
    </div>
  </aside>
</div>
    </section>
    <section class="more-proj">
      <div class="zag-proj">
      <h3>Похожие Проекты</h3>
        <a href="" class="ar-cont">
          <div class="icon-wrap-1">
          <img src="images/Arrow 112.svg" class="arrow-icon-1" alt="">
          </div>
        </a>
      </div>
        <div class="card-proj-list">
            <div class="image-container">
                <img src="images/foto4.png" alt="Фото 1" class="photo-472" data-tooltip="Описание первой фотографии">
                <div class="button-group">
                <a href="#" class="btn-drk">Branding</a>
                <a href="#" class="btn-drk">Logo</a>
                </div>
            </div>
            <div class="image-container">
                <img src="images/foto5.png" alt="Фото 2" class="photo-472" data-tooltip="Описание первой фотографии">
                <div class="button-group">
                <a href="#" class="btn-drk">Branding</a>
                <a href="#" class="btn-drk">Logo</a>
                </div>
            </div>
            <div class="image-container">
                <img src="images/foto1.png" alt="Фото 3" class="photo-472" data-tooltip="Описание первой фотографии">
                <div class="button-group">
                <a href="#" class="btn-wht">Branding</a>
                <a href="#" class="btn-wht">Logo</a>
                </div>
            </div>
        </div>
    </section>
    <footer class="footer">
  <div class="container">
    <div class="top-section">
      <p class="small-text">мы быстро ответим на ваш запрос</p>
      <div class="actions">
        <a href="" class="action">ЗАПОЛНИТЬ БРИФ</a>
        <a href="" class="action">ПОЗВОНИТЬ</a>
        <a href="" class="action">НАПИСАТЬ</a>
      </div>
    </div>
    <div class="bottom-section">
      <div class="left-block">
        <a href="">
        <img src="images/Group 19.svg" alt="2kie logo" class="logo">
        </a>
      </div>
      <div class="nav-footer">
    <div class="vertical-links-2">
      <a href="/cases" class="nav-link-2">Кейсы</a>
      <a href="/uslugi.html" class="nav-link-2">Услуги</a>
      <a href="/index.html" class="nav-link-2">Студия</a>
    </div>
  </div>
      <div class="right-block">
        <a href="" class="telegram-link-2">tg: @studio</a>
      </div>
    </div>
  </div>
</footer>
<script>
// 1. Инициализация переменных
const textPath = document.querySelector('svg textPath');
let lastScrollY = window.pageYOffset;
let rotationAngle = 0; // Начальный угол (0° — старт сверху)
const CIRCLE_LENGTH = 251.2; // Длина окружности (из атрибута textLength в SVG)
const SCROLL_SENSITIVITY = 0.5; // Чувствительность к скроллу (регулируйте по необходимости)

// 2. Функция обновления анимации текста при скролле
function updateTextPosition() {
  // Получаем текущую позицию скролла
  const currentScrollY = window.pageYOffset;
  
  // Вычисляем разницу между текущим и предыдущим скроллом
  const scrollDelta = currentScrollY - lastScrollY;
  
  // Рассчитываем изменение угла поворота текста
  const angleDelta = (scrollDelta * SCROLL_SENSITIVITY) % 360;
  rotationAngle += angleDelta;
  
  // Нормализуем угол в диапазоне [0, 360)
  rotationAngle = rotationAngle % 360;
  if (rotationAngle < 0) rotationAngle += 360;
  
  // Переводим угол в длину смещения по окружности (в единицах длины)
  const offsetLength = (rotationAngle / 360) * CIRCLE_LENGTH;
  
  // Обновляем атрибут startOffset у textPath (указываем длину, а не проценты)
  textPath.setAttribute('startOffset', offsetLength.toString());
  
  // Сохраняем текущую позицию скролла для следующего расчёта
  lastScrollY = currentScrollY;
}

// 3. Добавляем обработчик события скролла
window.addEventListener('scroll', updateTextPosition);

// 4. Опциональная оптимизация: дебаунсинг (ограничение частоты вызовов функции)
// Это сделает анимацию плавнее на слабых устройствах
let timeoutId;
function debouncedUpdateTextPosition() {
  clearTimeout(timeoutId);
  timeoutId = setTimeout(updateTextPosition, 16); // 60 FPS (1000 мс / 60 ≈ 16 мс)
}

// Заменяем прямой обработчик на дебаунсированный
window.removeEventListener('scroll', updateTextPosition);
window.addEventListener('scroll', debouncedUpdateTextPosition);
</script>
 <script>
(function(){
  const sections = Array.from(document.querySelectorAll('.case-section'));
  const navButtons = Array.from(document.querySelectorAll('.side-nav .nav-item:not(.nav-final)'));
  const finalBtn = document.querySelector('.nav-final');
  const track = document.getElementById('track');
  const indicator = document.getElementById('trackIndicator');
  const trackLine = document.getElementById('trackLine');
  const trackEndDot = document.getElementById('trackEndDot');
  const connector = document.getElementById('indicatorConnector');
  const connectorDot = document.getElementById('connectorDot');

  if(!sections.length || !track || !indicator || !trackLine || !trackEndDot) return;

  let trackRect = null;
  const lineTopOffset = -190; // ДОЛЖЕН совпадать с .track-line { top:12px } в CSS

  function updateRects(){
    trackRect = track.getBoundingClientRect(); // viewport coords
  }

  // ставим высоту линии так, чтобы она заканчивалась ровно по центру Final
  function updateTrackGeometry(){
    updateRects();
    const finalRect = finalBtn.getBoundingClientRect(); // viewport coords
    const finalCenterY = finalRect.top + finalRect.height / 2;

    // высота линии = расстояние от (trackRect.top + lineTopOffset) до finalCenterY
    let lineHeight = finalCenterY - (trackRect.top + lineTopOffset);
    // на случай если Final выходит за пределы трека — ограничим в границах trackRect
    const trackInnerHeight = trackRect.height - lineTopOffset - 8; // небольшая страховка снизу
    if(lineHeight < 8) lineHeight = 8;
    if(lineHeight > trackInnerHeight) lineHeight = trackInnerHeight;

    trackLine.style.height = `${Math.round(lineHeight)}px`;

    // позиция центра end-dot внутри track — top в px от верха track
    const endDotCenterY = lineTopOffset + lineHeight;
    trackEndDot.style.top = `${Math.round(endDotCenterY)}px`;
  }


  // Найти индекс ближайшей секции к центру экрана
  function getActiveSectionIndex(){
    const center = window.scrollY + window.innerHeight / 2;
    let nearest = 0, mind = Infinity;
    sections.forEach((s, i) => {
      const top = window.scrollY + s.getBoundingClientRect().top;
      const h = s.offsetHeight;
      const sectionCenter = top + h/2;
      const d = Math.abs(sectionCenter - center);
      if(d < mind){ mind = d; nearest = i; }
    });
    return nearest;
  }

  function updateNavVisuals(activeIndex){
    navButtons.forEach((btn, i) => {
      const dist = Math.abs(i - activeIndex);
      btn.classList.remove('size-large','size-medium','size-small','hidden','active');
      if(i === activeIndex){
        btn.classList.add('size-large','active');
      } else if(dist === 1){
        btn.classList.add('size-medium');
      } else if(dist === 2){
        btn.classList.add('size-small');
      } else {
        btn.classList.add('hidden');
      }
    });

    if(activeIndex === sections.length - 1){
      finalBtn.classList.add('active');
    } else {
      finalBtn.classList.remove('active');
    }
  }

  // Перемещаем индикатор на позицию активного пункта и обновляем connector
  function moveIndicatorTo(activeIndex){
    updateRects();

    const localTrackTop = trackRect.top + window.scrollY;
    let centerY = null;
    let targetNavRect = null;

    if(activeIndex >= 0 && activeIndex < navButtons.length){
      const rect = navButtons[activeIndex].getBoundingClientRect();
      centerY = window.scrollY + rect.top + rect.height / 2;
      targetNavRect = rect;
    } else {
      // если активна Final — позиция под треком (на конец)
      const finalRect = finalBtn.getBoundingClientRect();
      centerY = window.scrollY + finalRect.top + finalRect.height / 2;
      targetNavRect = finalRect;
    }

    // позиция центра индикатора внутри track (в px относительно top track)
    let centerInsideTrack = centerY - localTrackTop;
    const min = 8;
    const max = trackRect.height - 12;
    centerInsideTrack = Math.max(min, Math.min(max, centerInsideTrack));

    // Учитываем высоту индикатора — ставим top так, чтобы центр совпал
    const indicatorHalf = indicator.offsetHeight / 2;
    const indicatorTop = centerInsideTrack - indicatorHalf;
    indicator.style.top = `${indicatorTop}px`;

  }

  // Основной handler прокрутки
  function onScroll(){
    const active = getActiveSectionIndex();
    updateNavVisuals(active);
    moveIndicatorTo(active);
  }

  // Клики — плавный скролл
  navButtons.forEach(btn => {
    btn.addEventListener('click', (e) => {
      const id = btn.getAttribute('data-target');
      const el = document.getElementById(id);
      if(el) el.scrollIntoView({behavior:'smooth', block:'start'});
    });
  });
  finalBtn.addEventListener('click', ()=>{
    const id = finalBtn.getAttribute('data-target');
    const el = document.getElementById(id);
    if(el) el.scrollIntoView({behavior:'smooth', block:'start'});
  });

  // Resize / load handlers
  window.addEventListener('resize', () => {
    updateTrackGeometry();
    moveIndicatorTo(getActiveSectionIndex());
  });
  window.addEventListener('load', () => {
    updateTrackGeometry();
    moveIndicatorTo(getActiveSectionIndex());
    // небольшой таймаут на смену шрифтов
    setTimeout(()=>{ updateTrackGeometry(); moveIndicatorTo(getActiveSectionIndex()); }, 300);
  });
  window.addEventListener('scroll', () => {
    if(!window._navTicking){
      window.requestAnimationFrame(()=>{ onScroll(); window._navTicking = false; });
      window._navTicking = true;
    }
  }, {passive:true});

  // Инициализация
  updateTrackGeometry();
  moveIndicatorTo(getActiveSectionIndex());
})();
 </script>
 <script>
  document.addEventListener('DOMContentLoaded', function() {
  const images = document.querySelectorAll('img[data-tooltip]');
  const tooltip = document.createElement('div');
  tooltip.className = 'tooltip';
  document.body.appendChild(tooltip);

  let isTooltipVisible = false;

  images.forEach(img => {
    // При наведении
    img.addEventListener('mouseover', function(e) {
      const text = this.getAttribute('data-tooltip');
      tooltip.textContent = text;
      
      // Позиционируем подсказку справа-снизу от курсора
      const x = e.clientX + 12; // 12px отступа от курсора
      const y = e.clientY + 12;
      
      tooltip.style.left = x + 'px';
      tooltip.style.top = y + 'px';
      
      // Показываем подсказку
      tooltip.classList.add('show');
      isTooltipVisible = true;
    });

    // При уходе курсора
    img.addEventListener('mouseout', function() {
      tooltip.classList.remove('show');
      isTooltipVisible = false;
    });

    // При движении курсора обновляем позицию
    img.addEventListener('mousemove', function(e) {
      if (isTooltipVisible) {
        const x = e.clientX + 12;
        const y = e.clientY + 12;
        tooltip.style.left = x + 'px';
        tooltip.style.top = y + 'px';
      }
    });
  });
});
</script>
<script>
  document.addEventListener('DOMContentLoaded', function() {
  const links = document.querySelectorAll('.nav-link');
  const currentUrl = window.location.pathname;

  links.forEach(link => {
    // Сравниваем путь ссылки с текущим URL
    if (link.getAttribute('href') === currentUrl) {
      link.classList.add('active');
    }
  });
});
</script>
<script>
    document.addEventListener('DOMContentLoaded', function() {
  const muteBtn = document.getElementById('muteBtn');
  const img = muteBtn.querySelector('img');

  // Пути к изображениям
  const muteIcon = 'images/mute-Vector.svg';        // иконка «звук выключен»
  const unmuteIcon = 'images/unmute-Vector.svg';     // иконка «звук включён»

  // Начальное состояние: звук выключен (показываем mute-иконку)
  img.src = muteIcon;

  // Обработчик клика
  muteBtn.addEventListener('click', function() {
    if (img.src.includes(muteIcon)) {
      // Если сейчас иконка «выключено» — меняем на «включено»
      img.src = unmuteIcon;
    } else {
      // Если сейчас иконка «включено» — меняем на «выключено»
      img.src = muteIcon;
    }
  });
});
</script>
<script>
  document.addEventListener('DOMContentLoaded', function() {
  const animationElement = document.getElementById('typingAnimation');
  const text = 'agency';
  let isVisible = false;
  
  // Храним идентификаторы для очистки
  let typeInterval = null;
  let eraseInterval = null;
  let pauseTimeout = null;

  // Функция печати текста
  function typeText() {
    let i = 0;
    
    // Обязательно очищаем предыдущий интервал
    if (typeInterval) {
      clearInterval(typeInterval);
      typeInterval = null;
    }
    
    typeInterval = setInterval(() => {
      if (i < text.length) {
        animationElement.textContent = text.slice(0, i + 1);
        i++;
      } else {
        clearInterval(typeInterval);
        typeInterval = null;
        // Пауза перед стиранием (1 сек)
        pauseTimeout = setTimeout(eraseText, 1000);
      }
    }, 200); // 200 мс на символ
  }

  // Функция стирания текста
  function eraseText() {
    let i = text.length;
    
    // Очищаем предыдущий интервал стирания
    if (eraseInterval) {
      clearInterval(eraseInterval);
      eraseInterval = null;
    }
    
    eraseInterval = setInterval(() => {
      if (i > 0) {
        animationElement.textContent = text.slice(0, i - 1);
        i--;
      } else {
        clearInterval(eraseInterval);
        eraseInterval = null;
        
        // Запускаем новый цикл только если элемент виден
        if (isVisible) {
          typeText();
        }
      }
    }, 150); // 150 мс на символ
  }

  // Полная остановка всех процессов
  function stopAnimation() {
    if (typeInterval) clearInterval(typeInterval);
    if (eraseInterval) clearInterval(eraseInterval);
    if (pauseTimeout) clearTimeout(pauseTimeout);
    
    typeInterval = null;
    eraseInterval = null;
    pauseTimeout = null;
    
    animationElement.textContent = ''; // Очищаем текст
    isVisible = false;
  }

  // Проверка видимости элемента
  function checkVisibility() {
    const rect = animationElement.getBoundingClientRect();
    const inView = (
      rect.top >= 0 &&
      rect.left >= 0 &&
      rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
      rect.right <= (window.innerWidth || document.documentElement.clientWidth)
    );

    if (inView && !isVisible) {
      isVisible = true;
      typeText(); // Запускаем печать с начала
    } else if (!inView && isVisible) {
      stopAnimation(); // Полностью останавливаем
    }
  }

  // Обработчики событий (с throttle для оптимизации)
  function throttle(func, limit) {
    let inThrottle;
    return function() {
      if (!inThrottle) {
        func.call(this, arguments);
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
      }
    };
  }

  const throttledCheck = throttle(checkVisibility, 100);
  window.addEventListener('scroll', throttledCheck);
  window.addEventListener('resize', throttledCheck);

  // Первоначальная проверка видимости
  checkVisibility();
});
</script>
</body>
</html>

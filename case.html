<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2Kie da - case</title>
    <link rel="stylesheet" href="styles/style.css">
</head>
<body>
    <section class="hero-content">
    <img src="images/Rectangle 75.png" alt="">
    <div class="hero-overlay">
      <div class="logo-container">
        <a href="" target="_blank">
          <img src="images/Group white.svg" alt="Логотип 2kie">
        </a>
      </div>
      <div class="nav-wrapper">
    <div class="vertical-links">
      <a href="/case.html" class="nav-link">Кейсы</a>
      <a href="/uslugi.html" class="nav-link">Услуги</a>
      <a href="/index.html" class="nav-link">Студия</a>
    </div>
  </div>
      <div class="showreel-btn">
        <a href="" target="_blank">Showreel</a>
      </div>
      <div class="mute-btn" id="muteBtn">
        <img src="images/mute-Vector.svg" alt="Mute" width="17.63" height="17.63">
      </div>
    </div>
    <div class="play-btn" id="playBtn">
        <img src="images/play.svg" alt="Play">
    </div>
    <p class="name-studio">nazvanie studii</p>
    </section>
    <section class="info-block">
          <div class="video-block">
            <img src="images/Rectangle 84.png" alt="">
            <div class="podpis">О проекте “82494”</div>
            <div class="play-btn-2" id="playBtn">
              <img src="images/play.svg" alt="Play">
            </div>
          </div>
<div class="case-wrapper">
  <main class="case-left">
    <section id="s1" class="case-section"><h2>Nazvanie proecta</h2>
        <p>Проект создан для бренда, который стремился обновить своё цифровое присутствие и визуальный стиль. Наша задача заключалась в том, чтобы объединить эстетику, функциональность и характер бренда в единую систему. Мы провели глубокий анализ аудитории, выявили ключевые боли пользователей и выстроили логику взаимодействия, где каждый элемент работает осознанно.</p>
        <p>В процессе работы была разработана визуальная концепция, айдентика и интерфейс с акцентом на простоту, структуру и визуальный ритм. </p>
    </section>
    <section id="s2" class="case-section"><h2>Design</h2><p></p></section>
    <section id="s3" class="case-section"><h2>UX/UI</h2><p></p></section>
    <section id="s4" class="case-section"><h2>Web</h2><p></p></section>
    <section id="s5" class="case-section final"><h2>Final</h2><p></p></section>

    <div class="contact-page">
    <div class="button-container">
        <a href="#" class="button-left">Обсудить проект</a>
        <a href="#" class="button-right">
          <img src="images/Arrow 11.svg" alt="→">
        </a>
    </div>
        <div class="contact-block">
            <p>Напишите нам</p>
            <div class="social-buttons">
            <a href="" class="social-btn">WhatsApp</a>
            <a href="" class="social-btn">Telegram</a>
            </div>
        </div>
    </div>

  </main>
  <aside class="case-right" aria-label="Навигация по секциям">
    <div class="nav-inner">
    <div class="track" id="track">
      <div class="track-line" id="trackLine"></div>           <!-- вертикальная линия (будет динамичной высоты) -->
      <div class="track-end-dot" id="trackEndDot"></div>      <!-- маленькая окружность внизу напротив Final -->
      <div class="track-indicator" id="trackIndicator">       <!-- сам индикатор, внутри — connector -->
      <div class="connector" id="indicatorConnector"></div>
      <div class="connector-dot" id="connectorDot"></div>
      </div>
    </div>
      <nav class="side-nav" id="sideNav">
        <button class="nav-item" data-target="s1"><span class="num">1.</span><span class="title">Analitic</span></button>
        <button class="nav-item" data-target="s2"><span class="num">2.</span><span class="title">Design</span></button>
        <button class="nav-item" data-target="s3"><span class="num">3.</span><span class="title">UX/UI</span></button>
        <button class="nav-item" data-target="s4"><span class="num">4.</span><span class="title">Web</span></button>
        <!-- пустое пространство, final располагается отдельно -->
        <div class="nav-spacer"></div>
        <button class="nav-item nav-final" data-target="s5"><span class="num">Final</span></button>
      </nav>
    </div>
  </aside>
</div>
    </section>
    <section class="more-proj">
        <h2>More projects</h2>
        <div class="card-proj-list">
            <div class="image-container">
                <img src="images/pr1.png" alt="Фото 1" class="photo-472" data-tooltip="Описание первой фотографии">
                <div class="button-group">
                <a href="#" class="btn-drk">Branding</a>
                <a href="#" class="btn-drk">Design</a>
                <a href="#" class="btn-drk">Branding</a>
                </div>
            </div>
            <div class="image-container">
                <img src="images/pr2.png" alt="Фото 2" class="photo-472" data-tooltip="Описание первой фотографии">
                <div class="button-group">
                <a href="#" class="btn-drk">Branding</a>
                <a href="#" class="btn-drk">Design</a>
                </div>
            </div>
            <div class="image-container">
                <img src="images/pr5.png" alt="Фото 3" class="photo-472" data-tooltip="Описание первой фотографии">
                <div class="button-group">
                <a href="#" class="btn-drk">Branding</a>
                <a href="#" class="btn-drk">Design</a>
                <a href="#" class="btn-drk">Branding</a>
                </div>
            </div>
        </div>
    </section>
 <footer class="footer">
  <div class="footer-container">
    <div class="footer-left">
      <a href="" class="start-project-btn">Начать проект</a>
      <div class="social-buttons">
        <a href="" class="yt-btn">
            <img src="images/YTVector.svg" alt="YT-chanel">
        </a>
        <a href="" class="social-btn-2">WhatsApp</a>
        <a href="" class="social-btn-2">Telegram</a>
      </div>
    </div>
    <div class="footer-center">
      <p class="company-slogan">Создаем digital-продукт на базе стратегии, креатива и технологий</p>
      <p class="contact-email">Design@gmail.com</p>
      <p class="contact-phone">+7 (495) 384 04 05</p>
      <p class="telegram-label">Telegram для связи</p>
      <p class="telegram-handle">@Katetdesign</p>
    </div>
    <div class="footer-right">
      <img src="images/Group 18.svg" alt="2kie" class="logo">
      <p class="copyright">© 2017 - 2025</p>
      <div class="pdf-link">
            <a href="" class="pdf-icon">pdf</a>
            <p class="pdf-desc">Презентация компании</p>
      </div>
    </div>
  </div>
<div class="footer-bottom">
  <div class="agency-name" style="font-weight: 500;">
    creative digital 
    <span class="typing-animation" id="typingAnimation"></span>
  </div>
  <a href="" class="privacy-policy">Политика конфиденциальности</a>
</div>
 </footer>
 <script>
(function(){
  const sections = Array.from(document.querySelectorAll('.case-section'));
  const navButtons = Array.from(document.querySelectorAll('.side-nav .nav-item:not(.nav-final)'));
  const finalBtn = document.querySelector('.nav-final');
  const track = document.getElementById('track');
  const indicator = document.getElementById('trackIndicator');
  const trackLine = document.getElementById('trackLine');
  const trackEndDot = document.getElementById('trackEndDot');
  const connector = document.getElementById('indicatorConnector');
  const connectorDot = document.getElementById('connectorDot');

  if(!sections.length || !track || !indicator || !trackLine || !trackEndDot) return;

  let trackRect = null;
  const lineTopOffset = -190; // ДОЛЖЕН совпадать с .track-line { top:12px } в CSS

  function updateRects(){
    trackRect = track.getBoundingClientRect(); // viewport coords
  }

  // ставим высоту линии так, чтобы она заканчивалась ровно по центру Final
  function updateTrackGeometry(){
    updateRects();
    const finalRect = finalBtn.getBoundingClientRect(); // viewport coords
    const finalCenterY = finalRect.top + finalRect.height / 2;

    // высота линии = расстояние от (trackRect.top + lineTopOffset) до finalCenterY
    let lineHeight = finalCenterY - (trackRect.top + lineTopOffset);
    // на случай если Final выходит за пределы трека — ограничим в границах trackRect
    const trackInnerHeight = trackRect.height - lineTopOffset - 8; // небольшая страховка снизу
    if(lineHeight < 8) lineHeight = 8;
    if(lineHeight > trackInnerHeight) lineHeight = trackInnerHeight;

    trackLine.style.height = `${Math.round(lineHeight)}px`;

    // позиция центра end-dot внутри track — top в px от верха track
    const endDotCenterY = lineTopOffset + lineHeight;
    trackEndDot.style.top = `${Math.round(endDotCenterY)}px`;
  }


  // Найти индекс ближайшей секции к центру экрана
  function getActiveSectionIndex(){
    const center = window.scrollY + window.innerHeight / 2;
    let nearest = 0, mind = Infinity;
    sections.forEach((s, i) => {
      const top = window.scrollY + s.getBoundingClientRect().top;
      const h = s.offsetHeight;
      const sectionCenter = top + h/2;
      const d = Math.abs(sectionCenter - center);
      if(d < mind){ mind = d; nearest = i; }
    });
    return nearest;
  }

  function updateNavVisuals(activeIndex){
    navButtons.forEach((btn, i) => {
      const dist = Math.abs(i - activeIndex);
      btn.classList.remove('size-large','size-medium','size-small','hidden','active');
      if(i === activeIndex){
        btn.classList.add('size-large','active');
      } else if(dist === 1){
        btn.classList.add('size-medium');
      } else if(dist === 2){
        btn.classList.add('size-small');
      } else {
        btn.classList.add('hidden');
      }
    });

    if(activeIndex === sections.length - 1){
      finalBtn.classList.add('active');
    } else {
      finalBtn.classList.remove('active');
    }
  }

  // Перемещаем индикатор на позицию активного пункта и обновляем connector
  function moveIndicatorTo(activeIndex){
    updateRects();

    const localTrackTop = trackRect.top + window.scrollY;
    let centerY = null;
    let targetNavRect = null;

    if(activeIndex >= 0 && activeIndex < navButtons.length){
      const rect = navButtons[activeIndex].getBoundingClientRect();
      centerY = window.scrollY + rect.top + rect.height / 2;
      targetNavRect = rect;
    } else {
      // если активна Final — позиция под треком (на конец)
      const finalRect = finalBtn.getBoundingClientRect();
      centerY = window.scrollY + finalRect.top + finalRect.height / 2;
      targetNavRect = finalRect;
    }

    // позиция центра индикатора внутри track (в px относительно top track)
    let centerInsideTrack = centerY - localTrackTop;
    const min = 8;
    const max = trackRect.height - 12;
    centerInsideTrack = Math.max(min, Math.min(max, centerInsideTrack));

    // Учитываем высоту индикатора — ставим top так, чтобы центр совпал
    const indicatorHalf = indicator.offsetHeight / 2;
    const indicatorTop = centerInsideTrack - indicatorHalf;
    indicator.style.top = `${indicatorTop}px`;

  }

  // Основной handler прокрутки
  function onScroll(){
    const active = getActiveSectionIndex();
    updateNavVisuals(active);
    moveIndicatorTo(active);
  }

  // Клики — плавный скролл
  navButtons.forEach(btn => {
    btn.addEventListener('click', (e) => {
      const id = btn.getAttribute('data-target');
      const el = document.getElementById(id);
      if(el) el.scrollIntoView({behavior:'smooth', block:'start'});
    });
  });
  finalBtn.addEventListener('click', ()=>{
    const id = finalBtn.getAttribute('data-target');
    const el = document.getElementById(id);
    if(el) el.scrollIntoView({behavior:'smooth', block:'start'});
  });

  // Resize / load handlers
  window.addEventListener('resize', () => {
    updateTrackGeometry();
    moveIndicatorTo(getActiveSectionIndex());
  });
  window.addEventListener('load', () => {
    updateTrackGeometry();
    moveIndicatorTo(getActiveSectionIndex());
    // небольшой таймаут на смену шрифтов
    setTimeout(()=>{ updateTrackGeometry(); moveIndicatorTo(getActiveSectionIndex()); }, 300);
  });
  window.addEventListener('scroll', () => {
    if(!window._navTicking){
      window.requestAnimationFrame(()=>{ onScroll(); window._navTicking = false; });
      window._navTicking = true;
    }
  }, {passive:true});

  // Инициализация
  updateTrackGeometry();
  moveIndicatorTo(getActiveSectionIndex());
})();
 </script>
 <script>
  document.addEventListener('DOMContentLoaded', function() {
  const images = document.querySelectorAll('img[data-tooltip]');
  const tooltip = document.createElement('div');
  tooltip.className = 'tooltip';
  document.body.appendChild(tooltip);

  let isTooltipVisible = false;

  images.forEach(img => {
    // При наведении
    img.addEventListener('mouseover', function(e) {
      const text = this.getAttribute('data-tooltip');
      tooltip.textContent = text;
      
      // Позиционируем подсказку справа-снизу от курсора
      const x = e.clientX + 12; // 12px отступа от курсора
      const y = e.clientY + 12;
      
      tooltip.style.left = x + 'px';
      tooltip.style.top = y + 'px';
      
      // Показываем подсказку
      tooltip.classList.add('show');
      isTooltipVisible = true;
    });

    // При уходе курсора
    img.addEventListener('mouseout', function() {
      tooltip.classList.remove('show');
      isTooltipVisible = false;
    });

    // При движении курсора обновляем позицию
    img.addEventListener('mousemove', function(e) {
      if (isTooltipVisible) {
        const x = e.clientX + 12;
        const y = e.clientY + 12;
        tooltip.style.left = x + 'px';
        tooltip.style.top = y + 'px';
      }
    });
  });
});
</script>
<script>
  document.addEventListener('DOMContentLoaded', function() {
  const links = document.querySelectorAll('.nav-link');
  const currentUrl = window.location.pathname;

  links.forEach(link => {
    // Сравниваем путь ссылки с текущим URL
    if (link.getAttribute('href') === currentUrl) {
      link.classList.add('active');
    }
  });
});
</script>
<script>
    document.addEventListener('DOMContentLoaded', function() {
  const muteBtn = document.getElementById('muteBtn');
  const img = muteBtn.querySelector('img');

  // Пути к изображениям
  const muteIcon = 'images/mute-Vector.svg';        // иконка «звук выключен»
  const unmuteIcon = 'images/unmute-Vector.svg';     // иконка «звук включён»

  // Начальное состояние: звук выключен (показываем mute-иконку)
  img.src = muteIcon;

  // Обработчик клика
  muteBtn.addEventListener('click', function() {
    if (img.src.includes(muteIcon)) {
      // Если сейчас иконка «выключено» — меняем на «включено»
      img.src = unmuteIcon;
    } else {
      // Если сейчас иконка «включено» — меняем на «выключено»
      img.src = muteIcon;
    }
  });
});
</script>
<script>
  document.addEventListener('DOMContentLoaded', function() {
  const animationElement = document.getElementById('typingAnimation');
  const text = 'agency';
  let isVisible = false;
  
  // Храним идентификаторы для очистки
  let typeInterval = null;
  let eraseInterval = null;
  let pauseTimeout = null;

  // Функция печати текста
  function typeText() {
    let i = 0;
    
    // Обязательно очищаем предыдущий интервал
    if (typeInterval) {
      clearInterval(typeInterval);
      typeInterval = null;
    }
    
    typeInterval = setInterval(() => {
      if (i < text.length) {
        animationElement.textContent = text.slice(0, i + 1);
        i++;
      } else {
        clearInterval(typeInterval);
        typeInterval = null;
        // Пауза перед стиранием (1 сек)
        pauseTimeout = setTimeout(eraseText, 1000);
      }
    }, 200); // 200 мс на символ
  }

  // Функция стирания текста
  function eraseText() {
    let i = text.length;
    
    // Очищаем предыдущий интервал стирания
    if (eraseInterval) {
      clearInterval(eraseInterval);
      eraseInterval = null;
    }
    
    eraseInterval = setInterval(() => {
      if (i > 0) {
        animationElement.textContent = text.slice(0, i - 1);
        i--;
      } else {
        clearInterval(eraseInterval);
        eraseInterval = null;
        
        // Запускаем новый цикл только если элемент виден
        if (isVisible) {
          typeText();
        }
      }
    }, 150); // 150 мс на символ
  }

  // Полная остановка всех процессов
  function stopAnimation() {
    if (typeInterval) clearInterval(typeInterval);
    if (eraseInterval) clearInterval(eraseInterval);
    if (pauseTimeout) clearTimeout(pauseTimeout);
    
    typeInterval = null;
    eraseInterval = null;
    pauseTimeout = null;
    
    animationElement.textContent = ''; // Очищаем текст
    isVisible = false;
  }

  // Проверка видимости элемента
  function checkVisibility() {
    const rect = animationElement.getBoundingClientRect();
    const inView = (
      rect.top >= 0 &&
      rect.left >= 0 &&
      rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
      rect.right <= (window.innerWidth || document.documentElement.clientWidth)
    );

    if (inView && !isVisible) {
      isVisible = true;
      typeText(); // Запускаем печать с начала
    } else if (!inView && isVisible) {
      stopAnimation(); // Полностью останавливаем
    }
  }

  // Обработчики событий (с throttle для оптимизации)
  function throttle(func, limit) {
    let inThrottle;
    return function() {
      if (!inThrottle) {
        func.call(this, arguments);
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
      }
    };
  }

  const throttledCheck = throttle(checkVisibility, 100);
  window.addEventListener('scroll', throttledCheck);
  window.addEventListener('resize', throttledCheck);

  // Первоначальная проверка видимости
  checkVisibility();
});
</script>
</body>
</html>